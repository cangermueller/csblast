#!/usr/bin/ruby
require 'optparse'
require 'fileutils'
require 'erb'
require 'yaml'
require 'rubygems'
require 'bioinf'
require 'rsge'
require 'myconfig'

class CSTrainsetOpt
  class ScoreTable
    attr_accessor :repeat, :lltrain, :llval, :score
  end

  def initialize
    @paramsfile      = nil
    @cstrainset_file = nil
    @cssgd_file      = nil
    @csblast_file    = nil
    @csopt_file      = nil

    @outfile         = nil
    @outdir          = "."
    @workdir         = File.join(MyConfig.tmp_path, Process.pid.to_s)

    @vset            = false
    @verbose         = true
    @niter           = 2
    @rounds          = 2
    @repeats         = 1
    @cpu_cstrainset  = 1
    @cpu_cssgd       = 1
    @cpu_csopt       = 1
    @sge_pe          = ENV['SGE_PE']
    @opt_ll          = nil
    @keep_files      = false

    @fout = $stdout      # output stream
    @cssgd_cmds = []     # commands for cssgd
    @cstrainset_cmds = []# commands for cstrainset
    @csblast_cmds = []   # comamnds for csblast
    @csopt_cmds = []     # comamnds for csblast
    @round = 0           # rounds counter
    @k = 0               # optimization counter
    @ymax = 0            # optimal score
    @score_opt = nil     # optimal score
    @score_repeats = []  # score of all repeats of the current parameter configurations
    @cssgd_seeds = []    # seeds to be used for CSSGD calls

    self
  end

  def options
    OptionParser.new do |o|
      o.set_summary_indent('  ')
      o.banner = "Usage: #{$0} -p paramsfile -t cstrainset-script -s cssgd-script [options]"
      o.define_head( "Optimize homology detection performance of CSTRAINSET using CRF pseudocounts.")
      o.separator ""

      o.on("-p", "--paramsfile OPTFILE", "Parameter optimization file in YAML format.") { |val| @paramsfile=val }
      o.on("-t", "--cstrainset-script SCRIPT", "Job script for CSTRAINSET call.") { |val| @cstrainset_file=val }
      o.on("-s", "--cssgd-script SCRIPT", "Job script for CSSGD call.") { |val| @cssgd_file=val }
      o.on("-b", "--csblast-script SCRIPT", "Job script for CSBLAST call.") { |val| @csblast_file=val }
      o.on("-c", "--csopt-script SCRIPT", "Job script for CSOPT call.") { |val| @csopt_file=val }
      o.on("-d", "--dir DIRECTORY", "Output directory (default: #{@outdir})") { |val| @outdir=val }
      o.on("-o", "--outfile FILE", "Write optimization table to file.") { |val| @outfile=val }
      o.on("-w", "--work-dir DIRECTORY", "Working directory (default: #{File.join(MyConfig.tmp_path, "$PID")}).") { |val| @workdir=val }
      o.on("-v", "--[no-]vset", TrueClass, "Submit additional cstrainset jobs for creating the validation set (default: #{@vset})." ) { |val| @vset = val }
      o.on("-r", "--rounds INT", Integer, "Number of optimization rounds (default: #{@rounds})." ) { |val| @rounds = val }
      o.on("-n", "--niter INT", Integer, "Number of iterations with Newtons method (default: #{@niter})." ) { |val| @niter = val }
      o.on("-r", "--rounds INT", Integer, "Number of optimization rounds (default: #{@rounds})." ) { |val| @rounds = val }
      o.on("-R", "--repeats INT", Integer, "Number of repeats per parameter configuration (default: #{@repeats})." ) { |val| @repeats = val }
      o.on("--cpu-cstrainset INT", Integer, "Number of cpu cores to be used for a cstrainset job (default: #{@cpu_cstrainset})." ) { |val| @cpu_cstrainset = val }
      o.on("--cpu-cssgd INT", Integer, "Number of cpu cores to be used for a cssgd job (default: #{@cpu_cssgd})." ) { |val| @cpu_cssgd = val }
      o.on("--cpu-csopt INT", Integer, "Number of cpu cores to be used for a csopt job (default: #{@cpu_cssgd})." ) { |val| @cpu_cssgd = val }
      o.on("--sge-pe PE", String, "Name of the SGE parallel environment (default: #{@sge_pe})." ) { |val| @sge_pe = val }
      o.on("--opt-ll lltrain|llval", String, "Optimize the log likelihood on the training set (lltrain) or validation set (llval)  (default: #{@opt_ll})." ) { |val| @opt_ll = val }
      o.on("-k", "--keep-files", TrueClass, "Keep working directory (default: #{@keep_files})." ) {|val| @keep_files = true }
      o.on("-q", "--quiet", "Turn output off.") { |val| @verbose=false }
      o.on("-h", "--help", "Show this help message.") { puts o; exit }
    end
  end

  def check_args
    errors = []
    errors << "No parameter file given!" if @paramsfile.nil?
    errors << "No CSTRAINSET command file given!" if @cstrainset_file.nil?
    errors << "No CSSGD command file given!" if @cssgd_file.nil?
    if (@csopt_file)
      errors << "No CSBLAST command file given!" if @csblast_file.nil?
    end
    unless errors.empty?
      puts errors.join("\n")
      exit 1
    end
  end

  def run(args)
    options.parse!(args)
    check_args

    # read parameters for optimization
    fh = File.open(@paramsfile, 'r')
    @params = YAML::load(ERB.new(fh.read).result(binding))
    fh.close

    # read scriptfiles
    File.open(@cstrainset_file, 'r') do  |f|
      @cstrainset_cmds = f.readlines
    end
    File.open(@cssgd_file, 'r') do  |f|
      @cssgd_cmds = f.readlines
    end
    if @csopt_file
      File.open(@csblast_file, 'r') do  |f|
        @csblast_cmds = f.readlines
      end
      File.open(@csopt_file, 'r') do  |f|
        @csopt_cmds = f.readlines
      end
    end

    # define CSSGD seeds
    1.upto(@repeats) { @cssgd_seeds << rand(1e9) }

    # prepare output stream
    @fout = File.open(@outfile, 'w') if @outfile

    # do the optimization
    puts "Starting optimization in #{@workdir}..." if @verbose
    print_table_header
    @ymax = evaluate(@params)

    1.upto(@rounds) do |r|
      @round = r
      @params.keys.sort_by {|k| @params[k]['order'] }.each do |param|
        settings = @params[param]
        val_opt = optimize(param, settings)
        settings['value'] = val_opt
      end
    end
    print_table_line
    print_table_params(@params)
    print_table_score(@score_opt)
    @fout.close if @outfile
    FileUtils.rm_rf(@workdir) unless @keep_files
  end

  def optimize(param, settings)
    xl=nil # next parameter value to the left of xmax
    yl=nil # result for xl
    xr=nil # next parameter value to the right of xmax
    yr=nil # result for xr
    x =nil # next paramter value to be evaluated
    y =nil # result for $x
    bounced = false

    # go to the right side
    rxmax = settings['value']
    rymax = @ymax
    rxl = rxmax
    ryl = rymax
    rxr = nil
    ryr = nil
    loop do
      x = change_parameter_value(rxmax, settings, :right)
      if (settings['max'] && x >= settings['max'] || settings['min'] && x <= settings['min'])
        if bounced
          @ymax = rymax
          return rxmax
        else
          x = [x, settings['max']].min if settings['max']
          x = [x, settings['min']].max if settings['min']
          bounced=true
        end
      end
      p = copy(@params)
      p[param]['value'] = x
      y = evaluate(p, param)
      break if y <= rymax
      rxl = rxmax
      ryl = rymax
      rxmax = x
      rymax = y
    end
    rxr = x
    ryr = y

    # go to the left side
    if rymax <= @ymax || settings['goleft']
      lxmax = settings['value']
      lymax = @ymax
      lxl = nil
      lyl = nil
      lxr = lxmax
      lyr = lymax
      loop do
        x = change_parameter_value(lxmax, settings, :left)
        if (settings['max'] && x>= settings['max'] || settings['min'] && x <= settings['min'])
          if bounced || x == lxmax
            @ymax = lymax
            return lxmax
          else
            x = [x, settings['max']].min
            x = [x, settings['min']].max
            bounced=true
          end
        end
        p = copy(@params)
        p[param]['value'] = x
        y = evaluate(p, param)
        break if y <= lymax
        lxr = lxmax
        lyr = lymax
        lxmax = x
        lymax = y
      end
      lxl = x
      lyl = y
    end

    # do newton iterations
    if lymax.nil? || rymax > lymax
      xmax = rxmax
      @ymax = rymax
      xl = rxl
      yl = ryl
      xr = rxr
      yr = ryr
    else
      xmax = lxmax
      @ymax = lymax
      xl = lxl
      yl = lyl
      xr = rxmax == lxmax ? rxr : lxr
      yr = rxmax == lxmax ? ryr : lyr
    end
    @niter.times do
      # Fit y=a*x^2+b*x+c through the three points and set x = -a/2b
      xl2 = xl * xl
      xr2 = xr * xr
      xm2 = xmax * xmax
      x = (yl * (xm2 - xr2) + @ymax * (xr2 - xl2) + yr * (xl2 - xm2));
      x /= 1E-10 + (yl * (xmax - xr) + @ymax * (xr - xl) + yr * (xl - xmax)).abs.to_f * 2.0;
      x = format(x, settings['format'])
      break if (x <= xl || x >= xr)

      if (settings['mult'] && x/xmax > 1.01+1E-6 || settings['add'] && x-xmax > 0.005)
        p = copy(@params)
        p[param]['value'] = x
        y = evaluate(p, param)
        if (y > @ymax)
            xl = xmax;
            yl = @ymax;
            xmax = x;
            @ymax = y;
        else
          xr = x
          yr = y
        end
      elsif (settings['mult'] && xmax / x > 1.01+1E-6 || settings['add'] && xmax - x > 0.005)
        p = copy(@params)
        p[param]['value'] = x
        y = evaluate(p, param)
        if (y > @ymax)
          xr = xmax;
          yr = @ymax;
          xmax = x;
          @ymax = y;
        else
          xl = x
          yl = y
        end
      else
        break
      end
    end

    return xmax
  end

  def change_parameter_value(x, settings, mode=:right)
    ret = x
    case mode
    when :right: ret = settings['mult'] ? x.to_f * settings['mult'].to_f : x.to_f + settings['add'].to_f
    when :left:  ret = settings['mult'] ? x.to_f / settings['mult'].to_f : x.to_f - settings['add'].to_f
    end
    return format(ret, settings['format'])
  end

  def format(x, format = nil) 
    if format.nil? then
      return sprintf("%8.5g", x).to_f
    else
      x = sprintf(format, x)
      if x =~ /\./ then
        return x.to_f
      else
        return x.to_i
      end
    end
  end

  def copy(hash)
    ret = {}
    hash.each do |k,v|
      ret[k] = v.dup
    end
    return ret
  end

  def print_table_header
    row = ""
    row << sprintf("%-2s  %1s  %-10s  ", "#", "r", "optimizing")
    @params.each do |param,settings|
      row << sprintf("%-8s  ", param)
    end
    row << sprintf("%8s  %8s  ", "lltrain", "llval")
    row << sprintf("%8s  %8s", "score", "+/-%")
    @fout.puts row
    print_table_line
    @fout.flush
  end

  def print_table_line
    @fout.puts '-' * (57 + @params.length * 10)
  end

  def print_table_params(params, opt_param = nil, show = true)
    row = ""
    if (opt_param) then
      row << sprintf("%-2d  %1d  %-10s  ", @k, @round, opt_param)
    else
      row << ' ' * 19
    end
    params.each do |param,settings|
      row << sprintf("%-8s  ", settings['value'])
    end
    @fout.print show ? row : " " * row.length
    @fout.flush
  end

  def print_table_score(score)
    row = ""
    row << sprintf("%8.4f  %8.4f  ", score.lltrain, score.llval)
    row << sprintf("%8.4f  %+8.2f", score.score, 
                   @score_opt.nil? || @score_opt.score == 0.0 ? 0.0 : 
                   100.0 * (score.score - @score_opt.score) / @score_opt.score)
    @fout.puts row
    @fout.flush
  end

  def evaluate(params, opt_param = nil)
    print_table_params(params, opt_param)

    # clear the working directory
    FileUtils.rm_rf(@workdir)
    FileUtils.mkdir_p(@workdir)
    @score_repeats = []

    # prepare static template variables
    tplvars = Hash.new
    params.each do |param,settings|
      tplvars[param] = settings['value']
    end
    tplvars['workdir'] = @workdir
    
    # call cstrainset 
    call_cstrainset(tplvars)

    # call cssgd several times in parallel
    Thread.abort_on_exception = true
    1.upto(@repeats) do |r|
      Thread.new{call_cssgd(tplvars.dup, r)}
    end
    while @score_repeats.length < @repeats
      sleep(1)
    end

    # output the results
    @k += 1
    @score_repeats.sort! {|a, b| b.score <=> a.score}
    print_table_score(@score_repeats[0])
    1.upto(@score_repeats.length - 1) do |i|
      print_table_params(params, opt_param, false)
      print_table_score(@score_repeats[i])
    end

    # save the data if the current parameter configuration scores best
    if @score_opt.nil? || @score_repeats[0].score > @score_opt.score then
      @score_opt = @score_repeats[0]
      dirs = [File.join(@workdir, "cstrainset")]
      dirs.concat(Dir.glob(File.join(@workdir, sprintf("cssgd/%02d/*", @score_opt.repeat))))
      dirs.each do |dir|
        if File.directory?(dir)          
          FileUtils.rm_rf(File.join(@outdir, File.basename(dir)))
          FileUtils.cp_r(dir, @outdir)
        end
      end
    end

    return @score_repeats[0].score
  end

  def call_cstrainset(tplvars)
    tplvars['cstrainsetdir'] = "#{@workdir}/cstrainset"
    FileUtils.mkdir_p(tplvars['cstrainsetdir'])
    sge_config           = SGE::CONFIGURATION.dup
    sge_config[:logfile] = sprintf("%s/log", tplvars['cstrainsetdir'])
    sge_config[:args]    = sge_pe(@cpu_cstrainset)
    sge_config[:name]    = "cstrainset"
    qm          = SGE::Manager.new
    qm.verbose  = false
    qm.interval = 1
    qm.set_config(sge_config)
    0.upto(@vset ? 1 : 0) do |i|
      tplvars['cstrainsetvset'] = i
      cg = SGE::CommandGenerator.new
      cg.generate(@cstrainset_cmds.join("\n"), tplvars, {})
      qm.submit(cg.commands)
    end
    qm.wait
    check_for_errors(qm)
  end


  def call_cssgd(tplvars, repeat)
    # set up variables
    tplvars['cssgddir']  = sprintf("%s/cssgd/%02d/cssgd", @workdir, repeat)
    tplvars['cssgdout']  = "#{tplvars['cssgddir']}/out"
    tplvars['cssgdcrf']  = "#{tplvars['cssgddir']}/out.crf"
    tplvars['cssgdseed'] = @cssgd_seeds[repeat - 1]
    score        = ScoreTable.new
    score.repeat = repeat

    # submit the job
    FileUtils.mkdir_p(tplvars['cssgddir'])
    sge_config        = SGE::CONFIGURATION.dup
    sge_config[:args] = sge_pe(@cpu_cssgd)
    sge_config[:name] = sprintf("cssgd_%02d", repeat)
    cg = SGE::CommandGenerator.new
    cg.generate(@cssgd_cmds.join("\n"), tplvars, {})
    qm          = SGE::Manager.new
    qm.verbose  = false
    qm.interval = 1
    qm.set_config(sge_config)
    qm.submit(cg.commands)
    qm.wait
    check_for_errors(qm)

    # parse the cssgd output file
    raise "Unable to open '#{tplvars['cssgdout']}'!" unless File.exists?(tplvars['cssgdout'])
    File.open(tplvars['cssgdout'], 'r') do  |f|
      score.lltrain = nil
      score.llval = nil
      is_tab = false
      opt_llval = @opt_ll.nil? || @opt_ll == "llval"
      f.readlines.each do |l|
        if l =~ /^-+$/ then
          break if is_tab
          is_tab = true
        elsif is_tab == false
          next
        elsif l =~ /^\d+\s+\S+\s+(\S+)\s+\S+\s+\S+\s+(\S+)/ then
          lltrain = str_to_float($1)
          llval = str_to_float($2)
          raise "Invalid cssgd format: '#{tplvars['cssgdout']}'!" if (lltrain.nil? || llval.nil?)
          if score.lltrain.nil? || lltrain >= score.lltrain
            score.lltrain = lltrain
          end
          if score.llval.nil? || llval >= score.llval
            score.llval = llval
          end
        else
          break
        end
      end
      raise "Invalid cssgd format '#{tplvars['cssgdout']}'!" if score.llval.nil?
    end
    if (score.lltrain.infinite? || score.llval.infinite?) then
      # Invalid model
      score.score = 0.0
    elsif (@opt_ll) 
      score.score = @opt_ll == "lltrain" ? score.lltrain : score.llval
    elsif (@csopt_file)
      return call_csopt(tplvars, score)
    else
      score.score = score.llval
    end
    @score_repeats.push(score)
    return score.score
  end

  def call_csopt(tplvars, score)
    # set up variables
    tplvars['csoptdir'] = sprintf("%s/cssgd/%02d/csopt", @workdir, score.repeat)
    tplvars['csoptout'] = "#{tplvars['csoptdir']}/out"
    tplvars['csoptcsblast'] = File.join(tplvars['csoptdir'], File.basename(@csblast_file))

    # write csblast script file
    FileUtils.mkdir_p(tplvars['csoptdir'])
    fh = File.open(tplvars['csoptcsblast'], "w")
    fh.write(@csblast_cmds.dup.map{|l| l.gsub(/CSSGDCRF/, tplvars['cssgdcrf'])})
    fh.close
    
    # submit csopt jobs
    sge_config           = SGE::CONFIGURATION.dup
    sge_config[:logfile] = sprintf("%s/log", tplvars['csoptdir'])
    sge_config[:args]    = sge_pe(@cpu_csopt)
    sge_config[:name]    = sprintf("csopt_%02d", score.repeat)
    cg = SGE::CommandGenerator.new
    cg.generate(@csopt_cmds.join("\n"), tplvars, {})
    qm          = SGE::Manager.new
    qm.verbose  = false
    qm.interval = 1
    qm.set_config(sge_config)
    qm.submit(cg.commands)
    qm.wait
    check_for_errors(qm)

    # parse csopt output 
    raise "Unable to open '#{tplvars['csoptout']}'!" unless File.exists?(tplvars['csoptout'])
    score.score = nil
    File.open(tplvars['csoptout'], "r") do |fh|
      num_dashlines = 0
      fh.readlines.each do |line|
        if num_dashlines == 2
          fields = line.split(/\s+/)
          if fields.length > 2 && fields[fields.length - 2] =~ /^(\d+\.\d+)$/ then
            score.score = $1.to_f
          else
            break
          end
        elsif line =~ /^-+/
          num_dashlines += 1
        end
      end
    end
    raise "Invalid csopt format: '#{tplvars['csoptout']}'!" if score.score.nil?
    @score_repeats.push(score)
    return score.score
  end

  def str_to_float(s)
    s.strip!
    if (s =~ /^[+-]?\d+(\.\d+)$/) then
      return s.to_f
    elsif (s =~ /^[+-](nan|inf)$/i) then
      return 1.0 / 0.0 * (s =~ /^-/ ? -1.0 : 1.0);
    else
      return nil
    end
  end

  def check_for_errors(qm)
    if !qm.jobs_error.empty?
      $stderr.puts "There were #{qm.jobs_error.size} error(s) during parsing of results. Check following file(s):"
      qm.jobs_error.each { |job| $stderr.puts job.outfile }
      exit 1
    end
  end

  def sge_pe(cpu)
    return "-pe #{@sge_pe} #{cpu}"
  end

  def rocx_score(dir)
    #calculate ROCX score integral
    rocxfile = File.join(dir, 'rocx.dat')
    raise "Unable to parse ROCX data file #{rocxfile}" unless File.exists?(rocxfile)
    sum = 0.0
    File.open(rocxfile, 'r') do |f|
      lines = f.readlines.map {|line| line.strip }
      lines = lines.select {|line| line[0].chr!='#' }
      line = lines.shift
      x = line.split(/\s+/).first.to_f
      y = line.split(/\s+/).last.to_f
      lines.each do |line|
        tokens = line.split(/\s+/)
        x_new = tokens.first.to_f
        y_new = tokens.last.to_f
        sum += (x_new-x)*(y_new+y)/2
        x = x_new
        y = y_new
      end
    end
    return sum
  end

end

CSTrainsetOpt.new.run(ARGV)
