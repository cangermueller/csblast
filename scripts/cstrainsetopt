#!/usr/bin/ruby
require 'optparse'
require 'fileutils'
require 'erb'
require 'yaml'
require 'rubygems'
require 'bioinf'
require 'rsge'
require 'myconfig'

class CSTrainsetOpt
  class ScoreTable
    attr_accessor :repeat, :lltrain, :llval, :rocx
  end

  def initialize
    @paramsfile      = nil
    @cstrainset_file = nil
    @cssgd_file      = nil
    @csblast_file    = nil
    @csopt_file    = nil

    @outfile         = nil
    @outdir          = "."
    @workdir         = File.join(MyConfig.tmp_path, Process.pid.to_s)

    @verbose         = true
    @niter           = 2
    @rounds          = 2
    @repeats         = 1
    @cpu_cstrainset  = 1
    @cpu_cssgd       = 1
    @cpu_csopt       = 1
    @sge_pe          = "threads.pe"
    @opt_ll          = false
    @keep_files      = false

    @fout = $stdout      # output stream
    @cssgd_cmds = []     # commands for cssgd
    @cstrainset_cmds = []# commands for cstrainset
    @csblast_cmds = []   # comamnds for csblast
    @csopt_cmds = []   # comamnds for csblast
    @round = 0           # rounds counter
    @k = 0               # optimization counter
    @ymax = 0            # optimal score
    @score_opt = nil     # optimal score
    @score_repeats = []  # score of all repeats of the current parameter configurations
    @cssgd_seeds = []    # seeds to be used for CSSGD calls

    self
  end

  def options
    OptionParser.new do |o|
      o.set_summary_indent('  ')
      o.banner = "Usage: #{$0} -p paramsfile -t cstrainset-script -s cssgd-script -b csblast-script -x csopt-script [options]"
      o.define_head( "Optimize homology detection performance of CSTRAINSET using CRF pseudocounts.")
      o.separator ""

      o.on("-p", "--paramsfile OPTFILE", "Parameter optimization file in YAML format.") { |val| @paramsfile=val }
      o.on("-t", "--cstrainset-script SCRIPT", "Job script for CSTRAINSET call.") { |val| @cstrainset_file=val }
      o.on("-s", "--cssgd-script SCRIPT", "Job script for CSSGD call.") { |val| @cssgd_file=val }
      o.on("-b", "--csblast-script SCRIPT", "Job script for CSBLAST call.") { |val| @csblast_file=val }
      o.on("-x", "--csopt-script SCRIPT", "Job script for CSOPT call.") { |val| @csopt_file=val }
      o.on("-d", "--dir DIRECTORY", "Output directory (default: #{@outdir})") { |val| @outdir=val }
      o.on("-o", "--outfile FILE", "Write optimization table to file.") { |val| @outfile=val }
      o.on("-w", "--work-dir DIRECTORY", "Working directory (default: #{File.join(MyConfig.tmp_path, "$PID")}).") { |val| @workdir=val }
      o.on("-n", "--niter INT", Integer, "Number of iterations with Newtons method (default: #{@niter})." ) { |val| @niter = val }
      o.on("-r", "--rounds INT", Integer, "Number of optimization rounds (default: #{@rounds})." ) { |val| @rounds = val }
      o.on("-R", "--repeats INT", Integer, "Number of repeats per parameter configuration (default: #{@repeats})." ) { |val| @repeats = val }
      o.on("--cpu-cstrainset INT", Integer, "Number of cpu cores to be used for a cstrainset job (default: #{@cpu_cstrainset})." ) { |val| @cpu_cstrainset = val }
      o.on("--cpu-cssgd INT", Integer, "Number of cpu cores to be used for a cssgd job (default: #{@cpu_cssgd})." ) { |val| @cpu_cssgd = val }
      o.on("--cpu-csopt INT", Integer, "Number of cpu cores to be used for a csopt job (default: #{@cpu_cssgd})." ) { |val| @cpu_cssgd = val }
      o.on("--sge-pe PE", String, "Name of the SGE parallel environment (default: #{@sge_pe})." ) { |val| @sge_pe = val }
      o.on("--opt-ll", TrueClass, "Optimize the log likelihood instead of the ROCX score  (default: #{@opt_ll})." ) { |val| @opt_ll = true }
      o.on("-k", "--keep-files", TrueClass, "Keep working directory (default: #{@keep_files})." ) {|val| @keep_files = true }
      o.on("-q", "--quiet", "Turn output off.") { |val| @verbose=false }
      o.on("-h", "--help", "Show this help message.") { puts o; exit }
    end
  end

  def check_args
    errors = []
    errors << "No parameter file given!" if @paramsfile.nil?
    errors << "No CSTRAINSET command file given!" if @cstrainset_file.nil?
    errors << "No CSSGD command file given!" if @cssgd_file.nil?
    errors << "No CSBLAST command file given!" if @csblast_file.nil?
    errors << "No CSOPT command file given!" if @csopt_file.nil?
    unless errors.empty?
      puts errors.join("\n")
      exit 1
    end
  end

  def run(args)
    options.parse!(args)
    check_args

    # read parameters for optimization
    fh = File.open(@paramsfile, 'r')
    @params = YAML::load(ERB.new(fh.read).result(binding))
    fh.close

    # read scriptfiles
    File.open(@cstrainset_file, 'r') do  |f|
      @cstrainset_cmds = f.readlines
    end
    File.open(@cssgd_file, 'r') do  |f|
      @cssgd_cmds = f.readlines
    end
    File.open(@csblast_file, 'r') do  |f|
      @csblast_cmds = f.readlines
    end
    File.open(@csopt_file, 'r') do  |f|
      @csopt_cmds = f.readlines
    end

    # define CSSGD seeds
    1.upto(@repeats) { @cssgd_seeds << rand(1e9) }

    # prepare output stream
    @fout = File.open(@outfile, 'w') if @outfile

    # do the optimization
    puts "Starting optimization in #{@workdir}..." if @verbose
    print_table_header
    @ymax = evaluate(@params)

    1.upto(@rounds) do |r|
      @round = r
      @params.keys.sort_by {|k| @params[k]['order'] }.each do |param|
        settings = @params[param]
        val_opt = optimize(param, settings)
        settings['value'] = val_opt
      end
    end
    print_table_line
    print_table_params(@params)
    print_table_score(@score_opt)
    @fout.close if @outfile
    FileUtils.rm_rf(@workdir) unless @keep_files
  end

  def optimize(param, settings)
    xmax = settings['value']
    bounced = false
    xl=nil # next parameter value to the left of xmax
    yl=nil # result for xl
    xr=nil # next parameter value to the right of xmax
    yr=nil # result for xr
    x =nil # next paramter value to be evaluated
    y =nil # result for $x

    loop do
      x = change_parameter_value(xmax, settings, :right)
      if (settings['max'] && x>settings['max'] || settings['min'] && x<settings['min'])
        if bounced
          return xmax
        else
          x = [x, settings['max'].to_f].min if settings['max']
          x = [x, settings['min'].to_f].max if settings['min']
          bounced=true
        end
      end
      p = copy(@params)
      p[param]['value'] = x
      y = evaluate(p, param)
      break if y<=@ymax
      xl = xmax
      yl = @ymax
      xmax = x
      @ymax = y
    end
    xr = x
    yr = y

    if xl.nil?
      loop do
        x = change_parameter_value(xmax, settings, :left)
        if (settings['max'] && x>settings['max'] || settings['min'] && x<settings['min'])
          if bounced
            return xmax
          else
            x = [x, settings['max'].to_f].min
            x = [x, settings['min'].to_f].max
            bounced=true
          end
        end
        p = copy(@params)
        p[param]['value'] = x
        y = evaluate(p, param)
        break if y<=@ymax
        xr = xmax
        yr = @ymax
        xmax = x
        @ymax = y
      end
      xl = x
      yl = y
    end

    @niter.times do
      # Fit y=a*x^2+b*x+c through the three points and set x = -a/2b
      xl2 = xl*xl
      xr2 = xr*xr
      xm2 = xmax*xmax
      x = (yl*(xm2-xr2)+@ymax*(xr2-xl2)+yr*(xl2-xm2));
      x /= 1E-10 + ( yl*(xmax-xr)+@ymax*(xr-xl) +yr*(xl-xmax)).abs.to_f*2.0;
      x = format(x, settings['format'])
      break if (x <= xl || x >= xr)

      if (settings['mult'] && x/xmax>1.01+1E-6 || settings['add'] && x-xmax>0.005)
        p = copy(@params)
        p[param]['value'] = x
        y = evaluate(p, param)
        if (y>@ymax)
            xl = xmax;
            yl = @ymax;
            xmax = x;
            @ymax = y;
        else
          xr = x
          yr = y
        end
      elsif (settings['mult'] && xmax/x>1.01+1E-6 || settings['add'] && xmax-x>0.005)
        p = copy(@params)
        p[param]['value'] = x
        y = evaluate(p, param)
        if (y>@ymax)
          xr = xmax;
          yr = @ymax;
          xmax = x;
          @ymax = y;
        else
          xl = x
          yl = y
        end
      else
        break
      end
    end

    return xmax
  end

  def change_parameter_value(x, settings, mode=:right)
    ret = x
    case mode
    when :right: ret = settings['mult'] ? x.to_f*settings['mult'].to_f : x.to_f+settings['add'].to_f
    when :left:  ret = settings['mult'] ? x.to_f/settings['mult'].to_f : x.to_f-settings['add'].to_f
    end
    return format(ret, settings['format'])
  end

  def format(x, format = nil) 
    if format.nil? then
      return sprintf("%.5g", x).to_f
    else
      x = sprintf(format, x)
      if x =~ /\./ then
        return x.to_f
      else
        return x.to_i
      end
    end
  end

  def copy(hash)
    ret = {}
    hash.each do |k,v|
      ret[k] = v.dup
    end
    return ret
  end

  def print_table_header
    row = ""
    row << sprintf("%-2s  %1s  %-10s  ", "#", "r", "optimizing")
    @params.each do |param,settings|
      row << sprintf("%-8s  ", param)
    end
    row << sprintf("%-8s  %-8s  ", "lltrain", "llval")
    row << sprintf("%-8s  %6s", "ROC#{@rocx}", "+/-%")
    @fout.puts row
    print_table_line
    @fout.flush
  end

  def print_table_line
    @fout.puts '-' * (55 + @params.length * 10)
  end

  def print_table_params(params, opt_param = nil, show = true)
    row = ""
    if (opt_param) then
      row << sprintf("%-2d  %1d  %-10s  ", @k, @round, opt_param)
    else
      row << ' ' * 19
    end
    params.each do |param,settings|
      row << sprintf("%-8.4g  ", settings['value'])
    end
    @fout.print show ? row : " " * row.length
    @fout.flush
  end

  def print_table_score(score)
    row = ""
    row << sprintf("%-8.4f  %-8.4f  ", score.lltrain, score.llval)
    row << sprintf("%-8.4f  %+6.1f", score.rocx, 
                   @score_opt.nil? || @score_opt.rocx == 0.0 ? 0.0 : score.rocx/(@score_opt.rocx/100.0)-100.0)
    @fout.puts row
    @fout.flush
  end

  def evaluate(params, opt_param = nil)
    print_table_params(params, opt_param)

    # clear the working directory
    FileUtils.rm_rf(@workdir)
    FileUtils.mkdir_p(@workdir)
    @score_repeats = []

    # prepare static template variables
    tplvars = Hash.new
    params.each do |param,settings|
      tplvars[param] = settings['value']
    end
    tplvars['workdir'] = @workdir
    tplvars['cstrainsetdir'] = "#{@workdir}/cstrainset"
    tplvars['cstrainsettset'] = "#{tplvars['cstrainsetdir']}/tset"
    tplvars['cstrainsetvset'] = "#{tplvars['cstrainsetdir']}/vset"
    
    # call cstrainset 
    call_cstrainset(tplvars.dup)

    # call cssgd several times in parallel
    Thread.abort_on_exception = true
    1.upto(@repeats) do |r|
      Thread.new{call_cssgd(tplvars.dup, r)}
    end
    while @score_repeats.length < @repeats
      sleep(1)
    end

    # output the results
    @k += 1
    @score_repeats.sort! {|a, b| b.rocx <=> a.rocx}
    print_table_score(@score_repeats[0])
    1.upto(@score_repeats.length - 1) do |i|
      print_table_params(params, opt_param, false)
      print_table_score(@score_repeats[i])
    end

    # save the data if the current parameter configuration scores best
    if @score_opt.nil? || @score_repeats[0].rocx > @score_opt.rocx then
      @score_opt = @score_repeats[0]
      ["cstrainset", "cssgd"].each do |d|
        FileUtils.rm_rf(sprintf("%s/%s", @outdir, d))
        dir = sprintf("%s/%s", @workdir, d)
        FileUtils.cp_r(dir, @outdir) if File.directory?(dir)
      end
    end

    return @score_repeats[0].rocx
  end

  def call_cstrainset(tplvars)
    FileUtils.mkdir_p(tplvars['cstrainsetdir'])
    sge_config           = SGE::CONFIGURATION.dup
    sge_config[:logfile] = sprintf("%s/log", tplvars['cstrainsetdir'])
    sge_config[:args]    = sge_pe(@cpu_cstrainset)
    sge_config[:name]    = "cstrainset"
    cg = SGE::CommandGenerator.new
    cg.generate(@cstrainset_cmds.join("\n"), tplvars, {})
    qm          = SGE::Manager.new
    qm.verbose  = false
    qm.interval = 1
    qm.set_config(sge_config)
    qm.submit(cg.commands)
    qm.wait
    check_for_errors(qm)
  end


  def call_cssgd(tplvars, repeat)
    # set up variables
    tplvars['cssgddir'] = sprintf("%s/cssgd/%02d/cssgd", @workdir, repeat)
    tplvars['cssgdout'] = "#{tplvars['cssgddir']}/out"
    tplvars['cssgdcrf'] = "#{tplvars['cssgddir']}/out.crf"
    tplvars['cssgdseed'] = @cssgd_seeds[repeat - 1]
    score               = ScoreTable.new
    score.repeat        = repeat

    # submit the job
    FileUtils.mkdir_p(tplvars['cssgddir'])
    sge_config           = SGE::CONFIGURATION.dup
    sge_config[:args]    = sge_pe(@cpu_cssgd)
    sge_config[:name]    = sprintf("cssgd_%02d", repeat)
    cg = SGE::CommandGenerator.new
    cg.generate(@cssgd_cmds.join("\n"), tplvars, {})
    qm          = SGE::Manager.new
    qm.verbose  = false
    qm.interval = 1
    qm.set_config(sge_config)
    qm.submit(cg.commands)
    qm.wait
    check_for_errors(qm)

    # parse the cssgd output file
    raise "Unable to open '#{tplvars['cssgdout']}'!" unless File.exists?(tplvars['cssgdout'])
    File.open(tplvars['cssgdout'], 'r') do  |f|
      score.lltrain = nil
      score.llval = nil
      is_iter = false
      f.readlines.each do |l|
        if l =~ /^\d+\s+(\S+)\s+\S+\s+\S+\s+(\S+)\s+\S+$/ then
          lltrain = str_to_float($1)
          llval = str_to_float($2)
          raise "Invalid format: '#{tplvars[crfout]}'!" if (lltrain.nil? || llval.nil?)
          if score.llval.nil? || llval >= score.llval then
            score.lltrain = lltrain
            score.llval = llval
            is_iter = true
          elsif is_iter then 
            break
          end
        end
      end
      raise "Unable to parse '#{tplvars[crfout]}'!" if score.llval.nil?
    end
    if (score.lltrain.infinite? || score.llval.infinite?) then
      # Invalid model
      score.rocx = 0.0
      @score_repeats.push(score)
      return score.rocx
    elsif (@opt_ll) 
      score.rocx = score.llval
      @score_repeats.push(score)
      return score.rocx
    else
      return call_csopt(tplvars, score)
    end
  end

  def call_csopt(tplvars, score)
    # set up variables
    tplvars['csoptdir'] = sprintf("%s/cssgd/%02d/csopt", @workdir, score.repeat)
    tplvars['csoptout'] = "#{tplvars['csoptdir']}/out"
    tplvars['csoptcsblast'] = sprintf("%s/%s", tplvars['csoptdir'], File.basename(@csblast_file))

    # write csblast script file
    FileUtils.mkdir_p(tplvars['csoptdir'])
    fh = File.open(tplvars['csoptcsblast'], "w")
    fh.write(@csblast_cmds.dup.map{|l| l.gsub(/CSSGDCRF/, tplvars['cssgdcrf'])})
    fh.close
    
    # submit csopt jobs
    sge_config           = SGE::CONFIGURATION.dup
    sge_config[:logfile] = sprintf("%s/log", tplvars['csoptdir'])
    sge_config[:args]    = sge_pe(@cpu_csopt)
    sge_config[:name]    = sprintf("csopt_%02d", score.repeat)
    cg = SGE::CommandGenerator.new
    cg.generate(@csopt_cmds.join("\n"), tplvars, {})
    qm          = SGE::Manager.new
    qm.verbose  = false
    qm.interval = 1
    qm.set_config(sge_config)
    qm.submit(cg.commands)
    qm.wait
    check_for_errors(qm)

    # parse csopt output 
    raise "'#{tplvars['csoptout']}' does not exist!" unless File.exists?(tplvars['csoptout'])
    fh = File.open(tplvars['csoptout'], "r") 
    fields = fh.readlines.last.split
    fh.close
    if fields[fields.length - 2] =~ /^(\d+\.\d+)$/ then
      score.rocx = $1.to_f
    else
      raise "Invalid CSOPT output format: '#{tplvars['csoptout']}'!"
    end
    @score_repeats.push(score)
    return score.rocx
  end

  def str_to_float(s)
    s.strip!
    if (s =~ /^[+-]?\d+(\.\d+)$/) then
      return s.to_f
    elsif (s =~ /^[+-](nan|inf)$/i) then
      return 1.0 / 0.0 * (s =~ /^-/ ? -1.0 : 1.0);
    else
      return nil
    end
  end

  def check_for_errors(qm)
    if !qm.jobs_error.empty?
      $stderr.puts "There were #{qm.jobs_error.size} error(s) during parsing of results. Check following file(s):"
      qm.jobs_error.each { |job| $stderr.puts job.outfile }
      exit 1
    end
  end

  def sge_pe(cpu)
    return "-pe #{@sge_pe} #{cpu}"
  end

  def rocx_score(dir)
    #calculate ROCX score integral
    rocxfile = File.join(dir, 'rocx.dat')
    raise "Unable to parse ROCX data file #{rocxfile}" unless File.exists?(rocxfile)
    sum = 0.0
    File.open(rocxfile, 'r') do |f|
      lines = f.readlines.map {|line| line.strip }
      lines = lines.select {|line| line[0].chr!='#' }
      line = lines.shift
      x = line.split(/\s+/).first.to_f
      y = line.split(/\s+/).last.to_f
      lines.each do |line|
        tokens = line.split(/\s+/)
        x_new = tokens.first.to_f
        y_new = tokens.last.to_f
        sum += (x_new-x)*(y_new+y)/2
        x = x_new
        y = y_new
      end
    end
    return sum
  end

end

CSTrainsetOpt.new.run(ARGV)
