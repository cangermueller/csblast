#!/usr/bin/ruby
require 'optparse'
require 'erb'
require 'yaml'
require 'rubygems'
require 'bioinf'
require 'rsge'
require 'myconfig'

class CSBench
  class ScoreTable
    attr_accessor :score, :perc
  end

  def initialize
    @verbose      = true
    @force        = false
    @mode         = :rocx
    @inglob       = nil
    @rocx         = 5
    @error_rate   = 0.1
    @name         = ""
    @resglob      = '*.bla'
    @reference    = nil
    @outfile      = nil
    @seqfile      = nil
    @plots          = [:wtpfp, :rocx, :evalue]
    @benchfiles     = {
      :tpfp   => 'tpfp.dat',
      :wtpfp  => 'wtpfp.dat',
      :rocx   => 'rocx.dat',
      :pvalue => 'pvalue.dat',
      :evalue => 'evalue.dat'
    }

    @sge_config = SGE::CONFIGURATION.dup
    @sge_config[:logfile] = File.join(MyConfig.jobs_path, "csbench.log")
    @qm = SGE::Manager.new
    @qm.verbose = true
    @qm.interval = 2
    @i = 0 #submit counter

    self
  end

  def options
    OptionParser.new do |o|
      o.set_summary_indent('  ')
      o.banner = "Usage: #{$0} -d directory_glob -s seqfile [options]"
      o.define_head( "Evaluate homology detection performance of csBLAST versus BLAST.")
      o.separator ""

      o.on("-p", "--plots x,y,z", Array, "List of plots for which datafiles should be generated (default: #{@plots.join(',')})",
           "tpfp  :  TP versus FP ROC (unweighted)",
           "wtpfp :  TP versus FP ROC (weighted by number of family members)",
           "pvalue:  Real P-value versus reported P-value.",
           "evalue:  Real E-value versus reported E-value.",
           "rocx  :  ROCX threshold versus fraction of queries above threshold.") do |val|
        @plots = val.map {|p| p.to_sym }
      end
      o.on("-d", "--directories GLOB", Array, "Glob matching directories with csBLAST results.") { |val| @inglob=val }
      o.on("-s", "--seq-file FILE", "Sequence file with sequences and SCOP identifiers in FASTA format.") { |val| @seqfile=val }
      o.on("-o", "--outfile FILE", "Write summary table to file.") { |val| @outfile=val }
      o.on("-g", "--glob GLOB", "Glob matching resultfiles in each directory (default: #{@resglob}).") { |val| @resglob=val }
      o.on("-f", "--force", "Force result parsing and binning.") { |val| @force=true }
      o.on("-r", "--ref PATH", "Path to reference run (default: worst run)." ) { |val| @reference = val }
      o.on("-n", "--name NAME", "Basename for datafiles (default: #{@name}).") { |val| @name=val }
      o.on("-m", "--max JOBS", Integer, "Maximal number of concurrent jobs (default: #{@sge_config[:max_jobs]})." ) { |val| @sge_config[:max_jobs] = val }
      o.on("--rocx INT", Integer, "Maximal number of false positives threshold in ROCX calculation  (default: #{@rocx})." ) { |val| @rocx = val }
      o.on("--error-rate FLOAT", Float, "Error rate for wtpfp score calculation  (default: #{@error_rate})." ) { |val| @error_rate = val.to_f }
      o.on("--score SCORE", "Score in results table; rocx: mean ROC5, wtpfp: weighted TP at 10% error rate (default: #{@mode}) ") { |val| @mode=val.to_sym }
      o.on("-q", "--quiet", "Turn output off.") { |val| @verbose=false }
      o.on("-h", "--help", "Show this help message.") { puts o; exit }
    end
  end

  def check_args
    errors = []
    errors << "No sequence file given!" if @seqfile.nil?
    errors << "No input directories given!" if @inglob.nil?
    unless errors.empty?
      puts errors.join("\n")
      exit 1
    end
  end

  def run(args)
    if args.empty? then puts options; exit end
    options.parse!(args)
    check_args
    @sge_config[:logfile] = File.join(MyConfig.jobs_path, "csbench.log")
    @sge_config[:name] = "csbin"
    @qm.set_config(@sge_config)
    @qm.verbose = @verbose

    @dirs = []
    @inglob.each do |glob|
      @dirs << Dir.glob(glob).select {|d| File.directory?(d) }
    end
    @dirs << @reference unless @reference.nil? || @dirs.include?(@reference)

    #parse result files
    puts "Binning BLAST results..." if @verbose
    @i=0
    @dirs.each do |dir|
      prepare_benchmark_files(dir)
    end
    @qm.wait
    if !@qm.jobs_error.empty?
      $stderr.puts "There were #{@qm.jobs_error.size} error(s) during parsing of results. Check following file(s):"
      @qm.jobs_error.each { |job| $stderr.puts job.outfile }
      exit 1
    end

    print_summary if @verbose
  end

  def prepare_benchmark_files(dir)
    return if !@force && @plots.map {|p| @benchfiles[p] }.inject(true) {|memo,file| memo && File.exists?(File.join(dir, file)) }
    cmd = ["/cluster/user/andreas/bin/csbin -i '#{dir}/#{@resglob}' -d #{dir} --rocx #{@rocx} -s #{@seqfile} -p #{@plots.join(',')}"]
    @qm.submit(cmd)
    @qm.print_progress($stdout) if @verbose && @i%10==0
    @i += 1
  end

  def print_summary
    puts "Computing summary..." if @verbose
    scores = {}

    @dirs.each do |dir|
      run = File.basename(dir)
      datafile = File.join(dir, @benchfiles[@mode.to_sym])
      next unless File.exists?(datafile)
      File.open(datafile, 'r') do |f|
        st = ScoreTable.new
        lines = f.readlines.map {|line| line.strip }
        lines = lines.select {|line| line[0].chr!='#' }

        if @mode==:wtpfp
          data  = lines.map {|line| line.split(/\s+/).map {|s| s.to_f } }
          #calculate error rate = TP/(TP+FP) for each data point
          data.each_index do |i|
            data[i][2] = data[i][0] / (data[i][1]+data[i][0])
            if data[i][2]==@error_rate
              st.score = data[i][1]
            elsif i>0 && data[i][2]>@error_rate && data[i-1][2]<@error_rate
              #linear interpolation through point left and right from 10% error rate
              st.score = ( (data[i][1]-data[i-1][1])/(data[i][2]-data[i-1][2]) ) * (data[i][2]-data[i-1][2]) + data[i-1][1]
            end
          end
        else
          line = lines.shift
          x = line.split(/\s+/).first.to_f
          y = line.split(/\s+/).last.to_f
          sum = 0.0
          lines.each do |line|
            tokens = line.split(/\s+/)
            x_new = tokens.first.to_f
            y_new = tokens.last.to_f
            sum += (x_new-x)*(y_new+y)/2
            x = x_new
            y = y_new
          end
          st.score = sum
        end
        scores[run] = st
      end
    end
    return if scores.empty?

    runs = scores.keys.sort_by {|k| scores[k].score }.reverse
    ref_score = @reference ? scores[File.basename(@reference)].score : scores[runs.last].score
    scores.each {|key,st| st.perc = st.score/(ref_score/100.0)-100.0 }

    fout = @outfile ? File.open(@outfile, 'w') : $stdout
    fout.puts unless @outfile
    if @mode==:wtpfp
      fout.printf("%-3s  %-100s  %6s  %7s\n", "#", "run", "TPs", "+/-%")
    else
      fout.printf("%-3s  %-100s  %6s  %7s\n", "#", "run", "ROC#{@rocx}", "+/-%")
    end
    fout.puts "-"*122
    runs.each_index do |i|
      if @mode==:wtpfp
        fout.printf("%-3d  %-100s  %6.1f  %+6.1f%\n", i+1, runs[i], scores[runs[i]].score, scores[runs[i]].perc)
      else
        fout.printf("%-3d  %-100s  %6.4f  %+6.1f%\n", i+1, runs[i], scores[runs[i]].score, scores[runs[i]].perc)
      end
    end
    fout.close if @outfile
  end

  def check_for_errors
    @qm.update
    if !@qm.check
      $stderr.puts "There were #{@qm.jobs_error.size} error(s) during parsing of results. Check following file(s):"
      @qm.jobs_error.each { |job| $stderr.puts job.outfile }
      exit 1
    end
  end

end

CSBench.new.run(ARGV)
